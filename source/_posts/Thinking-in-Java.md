---
title: Thinking in Java
date: 2017-04-11 14:29:14
tags:
      - 计算机语言
      - 经典著作
categories: 深耕码农
mathjax: false
---


# 一、导论
* 对象都有一个接口
* private, protected, public和无限定词——包访问权限
* 组合与继承（覆盖方法、添加新方法）
* 多态
  * C++用Virtual表示，JAVA内部用一小段特殊代码表示，默认方法皆如此，自动进行upcasting
* 单根继承——Object
* 首先便于基本操作，heap new
* 其次GC
* 范型
* 异常
* WEB发展，前端JS APLLET 跨平台 后端  servlet JSP 跨平台消除异构浏览器的复杂性

# 二、一切为对象
* 引用
* 对象存储（寄存器、堆栈、堆、常量、持久化存储）
* 特例：基本类型
* 基本数据类型的作用域及对象的自动GC
* 类，成员默认值，局部变量依然是随机值，强制初始化
* 命名空间(com.apaceh.)，import，static
  * 静态变量提供与对象无关的存储空间分配；
  * 静态方法提供，直接调用 的方法，如main
* JAVADOC，帮你自动生成JAVA API文档
* 编码风格：驼峰

# 三四、操作符、控制流
* 引用，包括赋值、传递
* 一元加减操作符
* 逻辑运算符的短路现象：（）&&（）&&（），最短前两个即能判断该表达式
* 指数计数 、移位（注意-1的表示 方法）、三元操作符
* e作为10的幂次
* 字符串操作符+、+=，定义若表达式以一个字符串开头，后续所有操作数都必须是字符串，要不然强制转
* round()
* 没有sizeof
* for中的逗号操作符，foreach

# 五、初始化与清理
* 构造、重载（参数、顺序皆可，返回值不可，对于基本类型，传递参数可上升不可下降，因此要人工强制窄化）
* this返回本对象
* finalize，非析构，在GC时调用，可以认为是验证对象的终结，在调用NATIVE CODE时尤其有用
* GC

# 六、继承
* 类的加载：找到类文件，加载基类，加载主类，静态初始化、创建对象，成员初始化（基础类型为默认值，对象引用置空），构造器
* final成员、参数 、方法与类

# 七、多态（OO三种基本特征，抽象、继承、多态）
* 原理：upcasting,自动后期binding，除非final
20170709  只有普通方法的调用可以是多态的，如私有方法、域及静态方法
* 若要编码一个基础类，除非必需使用方法和成员，那么第一选择应该是使用接口；
* 基类——抽象方法——抽象类——接口，由具体到抽象，若一个基类是纯抽象的，而未告诉编译器它是抽象的或是个接口，那么，可能会因为误重载（本来是覆盖，因为参数不同，导致动态绑定失效）的原因，调用基类中的“伪”方法，造成非预知的问题。
* 接口：类默认为public，成员默认为staic和final ，可多重继承，
* 适配接口，策略设计模式
被适配的类 继承和实现基策略 任何类都可以通过为多重继承的方式被适配
* 接口中的任何域都是static和final的
* 接口可以嵌套，在类中或接口中 ，在类中private只能交给有权使用它的对象，即使他被一个public接口给实现；而嵌套在接口中则必须是public。
* 工厂模式，较通用，一般用于框架，代码可复用

# 十、内部类
# 十一、异常
* finally 在此处有用，处理异常下清理 ，但注意在构造方法中，不适合使用，而适在catch中处理
* 注意exception有丢失的可能可能性，比如被下一个exception覆盖（即catch内层有几层异常发生），又比如被finnally return .
* 异常匹配就近原则
* 异常及类型检查是必要的，但可以编译器和运行发生，只要它存在。反射及范型也是JAVA为编译期过多的检查所作的补偿。

# 十二、字符串
* string +  性能不如stringbuilder 使用javap可反编译分析，且JAVA5前是stringbuffer,而stringbuffer是线程安全的，效率不高。
* toString 可能会造成无穷递归调用 tostring, 如   tostring {  return 'a' + this ;},防止的方法是调用super.this
* system.out.printf/formatter 及formatter类、string.format()  用于格式化修饰%[argument_index$][flags][width][.precision]conversion， flags用于对齐， 如%05x,    右对齐，不足5位用0补齐
* string.match()/split()/replace()/replaceall()
# 十四：RTTI
* RTTI及反射使得运行时识别对象和类信息，而对象实际执行什么代码，这是有它指向的引用决定的，即多态机制。
* 通常希望大部分代码尽可能少了解对象具体类型，而只与对象家族的一个通用表示打交道。因此，多态是OOP的基本目标。
# 十五：范型
* 范型方法的 类型参数推断 ，基本类型的自动打包机制。类型参数推断的局限性在于只对赋值有效，这种局限可以通过显式的类型说明来弥补
* 范型方法可与可变参数配合
十六、数组
* 相对容器高效，但功能更少
* 初始化，对象为null，基本类型 char \0000 即转整型后为0
* 有个取不重复随机数的方法：
  ```java
  do
  t = rand.nextInt(len);
  while(picked[i]);
  ```
