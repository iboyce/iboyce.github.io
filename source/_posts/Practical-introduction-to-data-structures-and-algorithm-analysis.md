---
title: Practical introduction to data structures and algorithm analysis
date: 2017-09-28 11:12:18
tags:
      - 数据结构
      - 经典著作
categories: 深耕码农
mathjax: true
---

# 概率论及一些基础思考
## 代价与效益
在有效的资源下将问题解决，称该算法是有效的。一个好的数据结构（解决方案）设计首先要考虑到业务场景，在操作上（增删改查），它有什么需求。比如查询上要求并发高、但在插入速度上并无太高的要求，或者反之。
## 计算复杂度
* 通常我们考虑算法的在一定数据规模下的平均复杂度，但平均复杂度分析并不是一定可靠的，这建立在输入数据概率分布已知的情况下考虑的，通常这种假设每个元素出现的概率均等。但是不正确的假设也可能带来灾难的性的后果，特别是在搜索类算法上，如散列和搜索树，具体事例可参考9.4、5.4节。有时间考虑特殊的数据分布，也会带来好处，如9.2节（自组织线性表）
* 在实时系统中不考虑平均情况，而考虑最差的情况。
* 复杂度分析，通常采用渐近分析的方法，使用化简的方法计算上界，下界和平均情况。

## 最完美算法
联机算法——举例而言，最大子序列求和的问题
## 运行时间中的对数
* 如二叉树，contains操作，较明显，在常数据O(1)时间问题的大小缩减为其一部分（通过是一半或小于一半），则该算法是O(logN)
* 最大公因(约）数，即使用欧几里德/辗转相除法计算gcd(M,N)。由定理，若M>N，则有M mod N < M/2，可得该算法迭代次数至多是O(logN)
* 幂次运算，使用递归分解，将乘法降到O(logN)

# 基本数据结构
## 表、栈、队列
## 树

### 二叉树

可以使用栈来实现表达式树，也可用递归，这样会方便些。基本操作包括增(insert)、删(remove,两种可能性)、查(contains, findmin,findmax)，平均计算复杂度：

得O(nlogN)，但这无法控制上界，**为控制任意次连续M次操作在最坏的情况下花费时间为O(MlogN)，引入AVL平衡树，当然它无法保证单次的操作的时间界。最后根据二八法则，将引入伸展树**
### AVL平衡树

  使用单旋和双旋调整高度，结构上每个节点信息加入了高度。核心插入代码：
```C++
    void insert( const Comparable & x, AvlNode * & t )
    {
        if( t == NULL )
            t = new AvlNode( x, NULL, NULL );
        else if( x < t->element )
        {
            insert( x, t->left );
            if( height( t->left ) - height( t->right ) == 2 )
                if( x < t->left->element )
                    rotateWithLeftChild( t );
                else
                    doubleWithLeftChild( t );
        }
        else if( t->element < x )
        {
            insert( x, t->right );
            if( height( t->right ) - height( t->left ) == 2 )
                if( t->right->element < x )
                    rotateWithRightChild( t );
                else
                    doubleWithRightChild( t );
        }
        else
            ;  // Duplicate; do nothing
        t->height = max( height( t->left ), height( t->right ) ) + 1;
    }
```
### 伸展树
之形伸展与一字伸展，目标是沿访问路径旋转  
### 树的遍历
### B树——数据库的索引树，用于解决大量数据磁盘检索的问题
注意B树的定义，5个特性，M\L参数的确定。如一个区块8K，每个键32B，在一颗M阶的B树中有M-1个键，则可算出M。对于叶子节点若每个记录是256字节，区块是8K，则可算出L=32。再回来看定义：
1. 数据在叶子节点，并在相同深度上，且数据项介于L/2到L之间；
2. 非叶节点，存储M-1个键，指示查找方向，其儿子数在M/2到M之间;
注意B树插入时的分裂操作和删除的认领操作。

### STL中set和map的树形实现
### 散列
1. 散列函数:利用horner法则，计算多项式函数$h_k=k_0+37k_1+37k_2=(37+37k_2)k_1+k_0$。通常建议桶大小为素数
2. 冲突解决方法：分离链接、线性/平方探测、双散列。分离链接法因子可以到1，性能下降不明显，探测方法最好不超过0.5，双散列宜用质数。
3. 再散列：一般使用途中策略，到达装载因子再散列
4. hashmap, hashset
5. 散列比起二叉树而言速度虽有所提升但缺乏排序，通常用在比如编译器的符号表，拼写检查等等  

### 优先队列（堆）

##  排序与检索
## 高级话题
